# Templates

This is the source for the templates for our various types of pages. 

There are three types, excluding the home page (code that up separately)


## Page

This generates the pages. 

A section is run by tab panels for subections. It starts with an intro
overview panel, but after that, it is individual to each page. Each panel
should correspond to a hashing of the url which gets autogenerated. 

Use as `_"header|page type, _'intro', _'tab1', _'tab2', ..."`. If you need to add
per page css or js, then sub in `/*STYLE*/` or `//SCRIPT` after. In intro, the
first line should be a path while the second line should be a title. 

Each tab should start off with the first line as the tab name which also gets
slugified as a hash upon switching to the tab. 

The current idea of the intro is that when a tab is clicked( or hashed to),
then the intro collapses with the title (h2) becoming small and an expand
button being placed there alongside; it is sticky to the header. Implemented
for now as a details. 

The intro part should have the first line as a path, then the second line as
the title. 

We are using the standard md for markdown. It also handles some latex stuff.
By adding to a [prepost](https://github.com/jostylr/literate-programming/blob/master/project.md#md)


    function page (text, args) {
        let doc = this;
        const links =  _"listings::links";
        let type = args.shift();
        const firstLine = _"first line";
        const makePath = _"make path";
        const nextPrev = _"next prev";
        let md = (str) => str; 
        let ret = `_"html head"`;
        if (text) {
            ret += text;
        }
        ret += '</head><body>';
        let intro = args.shift().trim();
        console.log(intro);
        let path, title;
        [path, intro] = firstLine(intro);
        console.log(path, intro);
        ret += makePath(path);
        [title, intro] = firstLine(intro);
        ret.replace('TITLE', title);
        ret += `<sl-details summary="${title}"><${md(intro)}</sl-details>`;
        if (type === 'main') {
            _":cards|sub ITEM, book"
            ret += `<div class="cards main">${cards}</div>`;
        } else if (type === 'book') {
            _":cards | sub ITEM, chapter"
            ret += `<div class="cards book">${cards}</div>`;
        } else if (type === 'chapter') {
            _":cards | sub ITEM, section"
            ret += `<div class="cards chapter">${cards}</div>`;
        } else {
            _":tabs"
            ret += `<sl-tab-group>${tabNav}${tabs}</sl-tab-group>`;
        }
        ret += nextPrev(path);
        ret += `_"html close"`;
        return ret;
    }


[page](# "define:")

[temp.js](# "save:")


[tabs]()

This is where we create the tab interior. 

    let tabNav = '';
    let tabs = '';
    args.forEach( str => {
        let [name, content] = firstLine(str);
        tabNav += `<sl-tab slot="nav" panel="${name.toLowerCase()}">${name}</sl-tab>`;
        tabs += `<sl-tab-panel name="${name.toLowerCase()}">${md(content)}</sl-tab-panel>`;
    });

[cards]() 

    let cards = '';
    args.forEach( str => {
        let name, path, content;
        [name, str] = firstLine(str);
        [path, content] = firstLine(str);
        card += `<sl-card class="progress-${links[path][2]}"><div slot="header">${name}</div>${md(content)}<div slot="footer">Read on in this <sl-button href="${path}.html">ITEM</sl-button></sl-card>`;
    });

[card css]() 

We want the cards to be narrowed and to be displayed in a flexbox? 

    
    


## Make Path

So this makes the path heading. It should be in the form of
`book::chapter:section`. 

    (path) => {
        const item = _":item";
        const dcind = path.indexOf('::');
        let ret = '<nav class="crumbs"><ol>';
        const end = '</nav></ol>';
        if (!path) {
            ret += item('mp', 'MathPebbles', ''); 
            ret += end;
        }
        ret += item('mp', 'MathPebbles', '/');
        if (dcind === -1) {
            ret += item('book', path, ''); 
            ret += end; 
            return ret;
        } 
        const book = path.slice(0, dcind);
        path = path.slice(dcind+2);
        const cind = path.indexOf(':');
        if (cind === -1) {
            ret += item('book', book, '/'+ book); 
            ret += item('chapter', path, '');
            ret += end; 
            return ret;
        } 
        const chapter = path.slice(0, cind);
        const section = path.slice(cind+1);

        ret += item('book', book, '/'+book); 
        ret += item('chapter', chapter, '/'+book + '/' + chapter);
        ret += item('section', section, '');
        ret += end; 
        return ret;

    }

[item]()

This creates a nav item. Not sure the form, so wanted to keep it flexible.
Right now, it is a link. 

    (type, name, path) => {
        if (path) {
            return `<li class="crumb ${type}"><a href="${path.toLowerCase()}.html">${name}</a> </li>`;
        } else {
            return `<li class="crumb ${type}">${name}</li>`;
        }
    }

[css]() 

The crumb setup and css was originally from
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav) 

    .crumbs {
        border-bottom: 1px solid black;
    }

    .crumbs ol {
        list-style-type: none;
        padding-left: 0;
    }

    .crumb {
        display: inline-block;
    }

    .crumb a::after {
        display: inline-block;
        color: #000;
        content: '>';
        font-size: 80%;
        font-weight: bold;
        padding: 0 3px;
    }

## Next Prev

This creates the next and previous buttons. We need the [listings](listings.md
"load:") loaded.



    (path) => {
        const tr = _":transform";
        const [prev, next] = ( links[path.trim()] || ['','']);
        doc.log("path", path, prev, next, links[path]);
        const prevB = `<sl-button class="prev" href="${prev}"><sl-icon name="arrow-left" stye="font-size:20px;"></sl-icon>${tr(prev)}</sl-button>`;
        const nextB = `<sl-button class="next" href="${next}">${tr(next)}<sl-icon name="arrow-right" stye="font-size:20px;"></sl-icon></sl-button>`;
        return `<footer>${prevB}${nextB}</footer>`;
    }

[transform]()

This transforms the path info into human pleasing ideas. 

    (text) => {
        return text.
            replace(/\//g, '>').
            replace(/\-\-/g, ', ').
            replace(/\-/g, ' ');
    }

## First Line

A simple arrow function that takes in a text and returns a pair where the
first one is the first line and the second is the rest (new line stripped). 

    (str) => {
        str = str.trim();
        let ind = str.indexOf('\n');
        if (ind === -1) {
            return [str, ''];
        }
        return [str.slice(0, ind).trim(), str.slice(ind+1).trim()];
    }


## HTML Head

This is the head of the page, but leaving some stuff for the bottom. We do
reference the css from [common](common.md "load:")

    <!doctype html>
    <html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width,initial-scale=1.0'>
        <meta name='theme-color' content='#333333'>
        <title>TITLE</title>
    
Shoelaces. Load this first so submodules can load while others load. Found if
katex and jsxgraph were first, then they block loading of elements. 

        <link rel="stylesheet" href="/r/shoelace/shoelace.css">
        <script type="module" src="/r/shoelace/shoelace.esm.js"></script>

My homespun Var binding

        <script type="module">
            import {MP} from '/r/common.mjs';
            window.MP = MP;
            window.$ = MP.$
            window.$$ = MP.$$
            
        </script>


Katex  global: katex

        <link rel="stylesheet" href="/r/katex.css">
        <script defer src="r/katex.js" ></script>



JSXGraph  global: JXG

        
        <script type="text/javascript" charset="UTF-8" defer src="/r/jsxgraphcore.js"></script>
        <link rel="stylesheet" type="text/css" href="/r/jsxgraph.css" />

There is also math.js mainly used for high precision arithmetic. 

        <script typ="text/javascript" charset="UTF-8" defer src="/r/math.js"></script>


        <link rel='stylesheet' href='global.css'>
        <link rel='manifest' href='manifest.json' crossorigin='use-credentials'>
        <link rel="icon" type="image/svg+xml" href="favicon.svg">
        <link rel="alternate icon" href="favicon.ico">


        <style>
            .hide  {
                display:none;
            }
            sl-input {
                width: 20ch;
            }
            _"make path:css"
            _"page:card css"
            _"common::css"
        
            /*STYLE*/
        </style>


## HTML Close

We can put scripts and stuff here, but for now, we just close up. 

    
    <script>
         let m;
         document.addEventListener("DOMContentLoaded", function() {
            const {link, Var, show, hide } = MP;
            MP.mathSub(math);
            math.config({number:'BigNumber'});
            let keyInfo = MP.initKeys();
            //let makeScaledNumber = MP.initScaledNumber(math, JXG, keyInfo.keys); 
            let [makeTypedInput, types] = MP.initMakeTypedInput(math, JXG, keyInfo.keys); 
  
            _":events"

            //SCRIPT

        });

    </script>
    </body>
    </html>


[events]()

This is where we do some common behavior on event listening. 


    const detail = $('body > sl-detail');
    const stg = $('body > sl-tab-group');
     

## Section Example

This is an example to try out 

    <script>
        console.log('hey');
    </script>


[section.html](# "save: | page section, _':intro', _':section 1', _':section 2'" )

[intro]() 

    algebra/lines
    Lines
    This is a sample intro lines

[section 1]()

    Shortest Distance
    The shortest distance between two lines is ...

[section 2]( )

    Lines, Circles, Angles, and Triangle
    Diffrent cool shapes



## Book Example

This is just the same as the section example except it is a book. 



[book.html](# "save: | page section, _':intro', _':section 1', _':section 2'" )

[intro]() 

    algebra/lines
    Lines
    This is a sample intro lines

[section 1]()

    Shortest Distance
    The shortest distance between two lines is ...

[section 2]( )

    Lines, Circles, Angles, and Triangle
    Diffrent cool shapes


