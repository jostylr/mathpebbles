# Templates

This is the source for the templates for our various types of pages. 

There are three types, excluding the home page (code that up separately)


## Page

This generates the pages. 

A section is run by tab panels for subections. It starts with an intro
overview panel, but after that, it is individual to each page. Each panel
should correspond to a hashing of the url which gets autogenerated. 

Use as `_"header|page type, path, title, _'intro', tab title, _'tab1|md', tab title, _'tab2', ..."`. If you need to add
per page css or js, then sub in `/*STYLE*/` or `//SCRIPT` after. In intro, the
first line should be a path while the second line should be a title. 

Each tab should start off with the first line as the tab name which also gets
slugified as a hash upon switching to the tab. 

The current idea of the intro is that when a tab is clicked( or hashed to),
then the intro collapses with the title (h2) becoming small and an expand
button being placed there alongside; it is sticky to the header. Implemented
for now as a details. 

The intro part should have the first line as a path, then the second line as
the title. 

We are using the standard md for markdown. It also handles some latex stuff.
By adding to a [prepost](https://github.com/jostylr/literate-programming/blob/master/project.md#md)


    function page (text, args) {
        const links =  _"listings::links";
        const slugify = _"slugify";
        const progress = _"progress";
        const makePath = _"make path";
        const makeNav = _"make nav";
        const nextPrev = _"next prev";
        const shoelacify = _"shoelace full";
        const base = `_"html"`;
        let pieces = base.split('!-!');
        const replace = {};
        let path = args[0];

The path should start with a slash, but easy to forget. 

        if (path[0] !== '/') {
            path = '/' + path;
        }
        replace.NAV = makeNav(path);
        replace.TITLE = links[path]?.name ?? 'MathPebbles'; //index is not in the listings
        _":populate replace"
        
        let main = '';
        _":details"
        replace.MAIN = main;

        replace.FOOTER = `<footer>${makePath(path)[1]}</footer>`; //nextPrev(path);
        
        const fanoSymbols = [];
        {_":populate fano"}
        replace.FANO = `<div class="fano">_"make fano"</div>`;
        
        let ret =  pieces.
            map( key => {
                if (key.match(/^[A-Z]+$/)) {
                    return replace[key] || '';
                } else {
                    return key;
                }
            }).
            join('\n');
       
       /*
        let minify = this.Folder.plugins.htmlmin;

        minify(ret, {
            minifyCSS : true,
            minifyJS : true
        });
       */

        return ret;
    }


[page](# "define:")

[temp.js](# "save:")


[populate replace]()

So the text should have `!-NAME\n` stuff and the Name is the key and the stuff
until the next one 

    let indpr;
    let key = '';
    while (  (indpr = text.indexOf('!-')) !== -1) {
        if (key) {
            replace[key] = text.slice(0, indpr);
        }
        text = text.slice(indpr+2);
        let indnew = text.indexOf('\n');
        key = text.slice(0, indnew).trim().toUpperCase();
        text = text.slice(indnew+1);
    }
    if (key) {
        replace[key] = text;
    }

[populate fano]()

This fills the array that will be used to populate the fano diagram on each
page. If there are no symbols or children, then we go to the parent. 


    let positions = [
        "(50,500)", //1
        "(300,500)", //2
        "(550,500)", //3
        "(425,283.49)", //4
        "(175,283.49)", //5
        "(300,66.987)", //6
        "(300,355.662)", //7
    ]
    let children = [];
    let curPath = path;
    if (path === '/index') { curPath = '/';}
    let link = links[curPath];
    if ( (link.type === 'main') || (link.type === 'book') ) {
        link = links['/'];
    } else if (link.type === 'section') {
        link = links[link.prefix]; // chapter
        if (!link.children[0][2]) { //no section symbols so use chapter
            link = links[link.prefix];
        }
    }  else {// chapters
        link = links[link.prefix];
    }
    children = link.children.slice(0);
    children.forEach( ([name, path, symbol], ind) => {

We have a non-tex thing when the lead character is a percent.

        let type='latex', x=-7, y=-7, w=20, h=23, scalex=1.4, scaley=1.4;
        if (symbol[0] === '%') {
            let ind = symbol.indexOf(':');
            if (ind === -1) { 
                console.log("invalid symbol", symbol, name, path); 
                
            }
            type = symbol.slice(1,ind).trim(); 
            symbol = symbol.slice(ind+1).trim(); 

The type can also have x,y,width,height coordinates embedded, in that order.
It requires being in parentheses. To do this with latex, the type has to be
specifically given and then use parentheses. But really for the latex, we want
x, y, scalex, and scaley.  To do this do a % followed by up to 4 numbers

            if (type.includes('\u0028') ) {   //open parentheses
                let par;
                [type, par] = type.split('\u0028');
                [x=x,y=y,w=w,h=h] = par.
                    split('\u0029')[0].  
                    split(',').
                    map( e => e || undefined); //get rid of empty strings so as default
            }
        } 
        if (type==='svg') {
            fanoSymbols.push( `<a href="${path}.html" title="${name}" transform="translate${positions[ind]}" stroke="black" stroke-width="1px">
    <circle r="20" fill="white" />
    <image href="/img/${symbol}.svg" x="${x}" y="${y}" width="${w}" height="${h}"></image>
    </a>`);
        } else if (type === 'latex') {
            if (symbol.includes('%')) {
                let nums;
                [symbol, nums] = symbol.split('%').map( s=> s.trim() );
                [x=x,y=y,scalex=scalex,scaley=scaley] = nums.split(/\s+/);
            }
            symbol = symbol.replaceAll('\\u0025', '\\%');
            fanoSymbols.push( `<a href="${path}.html" title="${name}" transform="translate${positions[ind]}" stroke="black" stroke-width="1px">
    <circle r="20" fill="white" />
    <g class="fano-math" data-type="latex" data-text="${symbol}"
    transform="translate(${x} ${y}) scale(${scalex} ${scaley})" >
    </g></a>`);
    
    } else {
        fanoSymbols.push( `<a href="${path}.html" title="${name}" transform="translate${positions[ind]}" stroke="black" stroke-width="1px">
    <circle r="20" fill="white" />
    <foreignObject x="${x}" y="${y}" width="${w}" height="${h}">
    <div class="fano-math" data-type="${type}" data-text="${symbol}"></div>
    </foreignObject>
    </a>`);
    }
    });


[details]() 

This is the generator of the details. The stuff comes in pairs with the first
one being either a section name only or an array with the first element being
the section name and the second one being a path for the Explore button. 

   
    let n = args.length;
    for (let i = 0; i < n; i+=2)  {
        let lpath = args[i];
        let item = links[lpath];
        let name, href;
        if (item) {
            name = item.name;
            href = lpath;
        } else if (lpath==='/index') {
            name = 'MathPebbles';
        } else {
            name = lpath;
        }
        let heading; 
        if ((i !== 0) && (href)) {  // not intro
            heading = `    <h2 class="with-explore"><span class="heading">${name}</span>`+
                `<a class="explore" href="${href}.html">` +
                `Explore </a></h2> \n\n` ; 
        } else {
            heading = `<h2>${name}</h2>`;
        }
        const body = args[i+1].trim();
        let [preview, full] = body.split('<p>!-</p>').map( e => e.trim());
        preview = shoelacify(preview);
        full = shoelacify(full || ''); 
        let self=slugify(name);
        if (full) {
            main += `<div class="top section" id="${self}" x-data="section" x-init="me('${self}')">
                <div class="summary">
                    _":heading"
                    ${preview}
                </div>
                <div class="full" x-show="open" x-cloak>
                ${full || ''}
                </div>
                <ul class="footer" x-show="footCount" x-init="footer = $el"></ul>
                </div>`;
        } else {
            main += `<div id="${self}" x-data="section" x-init="me('${name}')" class="top">${heading}${preview}<ul class="footer" x-show="footCount"></ul> </div>`;
        }
    }

[heading]() 

The heading here is for sections with details to reveal. This is specifically
not to be those with explore buttons. 

    <h2>${name} 
        <button @click="open =  ! open" x-text="open ? 'Less...' : 'More...'">More...</button>
    </h2>

## Shoelace full

This is a complicated bit of code where we use our own little crappy DSL to
slot in elements of the shoelace variety (and maybe others too) 

Here is the lingo. All of the special stuff is of the form !NAME. Some have
some verbage on that same line, most don't. Many consume stuff in subsequent
lines until some ending tag. 

* PEBBLE  Single line, takes in a pebble name. The code to create it is found
  elsewhere. 
* VIDEO Single line, two pieces: a url with no space and then the rest is a
  title
* PROOF: whatever for a proof environment.  QED.
* DETAILS: Expects a list where per item first paragraph is the summary and
  the rest are the details. Each list item is its own detail. For now, no
  sublists please! If you need sublists, use the longer form SUMMARY/DETAIL.
  Ends with OVER.
* SUMMARY: (summary stuff) DETAIL: (detail stuff) DONE.  A standalone detail
  item
* PROGRAM: whatever for a program environment. STOP.
* CODE name: starting code block  SOLUTION: Some explanatory text and a code
  block to sub in for the solution. END.
* FOOTNOTE: This pops up from the bottom. It ends with SOCK. 


Colons are totally optional, I hope. 

---

    function shoelacify (text) {
        let reg = /\!([A-Z]+)\:?(.*)$/;
        let lines = text.split('\n');
        let place = 0;
        let ret = [];
        let n = lines.length;
        let i;
        places = [];
        for (i = 0; i < n; i+= 1) {
            let line = lines[i];
            if (line.slice(0,4) === '<p>!') {
                let match = line.match(reg);
                let type = match?.[1] || '';
                let end = (match?.[2] || '').
                    trim().
                    slice(0, -4); //slice is to get rid of closing p element
                let p; // local place 
                switch (type) {
                case 'PEBBLE' : 
                    ret.push(`<div class="pebble" id="${end}" x-effect="${end}($el)"></div>`);
                break; 
                case 'VIDEO':
                    _":video"

                break;
                case 'PROOF':
                    _":proof"
                break;
                case 'QED':
                    _":qed"
                break;
                case 'DETAILS': 
                    { _":details" }
                break;


The structure of the details and summary is a little complicated. We have an
overall detail div for styling. The summary div contains a div with the
summary information as well as a button for toggling the details. The summary
div is for a flex to push the button to the far right.  

                case 'SUMMARY':
                    p = place += 1;
                    places.push(p);
                    ret.push(`<div class="detail" x-init="togglers[${p}] = false">
                    <div class="blurb">
                    <button @click.stop="togglers[${p}] = ! togglers[${p}]" 
                    x-html = "caret( togglers[${p}] )"></button>
                    <div>`);
                break;
                case 'DETAIL': 
                    p = places.pop();
                    ret.push(`</div></div>
                    <div x-show="togglers[${p}]" x-transition.scale.origin.top> `);
                break; 
                case 'DONE':
                    ret.push('</div></div>');
                break;
                case 'PROGRAM' :
                   _":proof | sub Proof, Program, left, right" 
                break;
                case 'STOP':
                    _":qed"
                break;
                case 'CODE': 
                    { _":code" }
                break; 
                case 'SOLUTION':
                    p = places.pop();
                    ret.push(`</div><div x-show="togglers[${p}]">`);
                break;
                case 'END':
                    ret.push('</div></div>');
                break;
                default: 
                    ret.push(line);
                }
            } else {
                ret.push(line);
            }
        }

        return ret.join('\n');
    }


[video]() 

This takes in a video url followed by a space followed by a title. The display
is the title followed by a caret thing. 



    end = end.trim();
    let ind, url, title;
    if (end.slice(0,2) === '<a') {
        ind = end.indexOf('</a>');
        url = end.slice(0, ind).match(/href\=\"([^"]+)\"/)?.[1];
        title = end.slice(ind+5).trim();
    } else {
        ind = end.indexOf(' ');
        url = 'https://player.vimeo.com/video/' + end.slice(0, ind) + '?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479';
        title = end.slice(ind+1).trim();
    }
    p = place += 1; 
    ret.push(`<div class="video" x-init="togglers[${p}]= false "> 
    <h4>Video: ${title} 
        <button @click.stop ="togglers[${p}] = ! togglers[${p}]"
        x-html = "caret( togglers[${p}] ) "></button>
    </h4>

Doing the weird dynamic source thing because it seems to remember and get
locked in when being refreshed with a new source. Since I may want to change
links, ... I really don't understand this problem, here is a link to Firefox
bug page:  https://bugzilla.mozilla.org/show_bug.cgi?id=363840


    <iframe x-cloak x-show="togglers[${p}]" src="about:blank" x-init="$el.src = '${url}'" frameborder="0" allow="fullscreen; picture-in-picture" title="${title}"></iframe>

    </div>
    `); 

[proof]()

    p = place += 1;
    places.push(p);
    ret.push(` <button @click="togglers[${p}] = true">Proof</button>
        <div class="overlay" x-effect="overlay = togglers[${p}]"  
        x-show="togglers[${p}]"
        x-transition.scale.origin.left >
        <div class="left" 
        @click.outside="togglers[${p}] = false"  
        x-init="togglers[${p}] = false" >`
    );


[qed]() 

    p = places.pop();
    ret.push(`</div><button class="close" @click="togglers[${p}] = false">Close</button>
    </div> `);


[code]() 


This creates the try code block. 

    p = place +=1;
    places.push(p);
    let title = end.trim().toLowerCase() || 'noop';
    ret.push(`<div class="code" x-data="code" x-init="${title}()" >
         <div class="try">
         <div class="editor language-js line-number match-braces" x-init="start( $el , '${title}')"></div>
        <pre x-text="log.join('\\n')"></pre>
        <div class="buttons">
        <button @click.stop="save()">Save</button>
        <button @click.stop="run()">Run</button>
        <button @click.stop="reset()">Reset</button>
        <button @click.stop="restore()">Restore</button>
        <button style="display: inline-flex; padding-bottom: 3px;"
        @click.stop ="togglers[${p}] = ! togglers[${p}]"
        x-html = "caret( togglers[${p}], 'Show Working Program' ) "></button>
        </div>
        <div x-html="out"></div>`);




[junk]()

            <textarea spellCheck="false" 
            @input="updateCode($el) " 
            @keydown.alt.tab.stop = "checkTab($el, 4)"
            ></textarea>
            <pre class="line-numbers language-javscript match-braces"><code></code></pre>



[try el]() 

Not sure how to easily grab this in another way. Anticipate it changing. 

    $el.parentElement.parentElement.firstElementChild

[details]()

This is the one complicated bit. The details takes a list and converts each
item into a detail object. The first paragraph becomes the summary (slot =
summary). If a list is not the thing immediately after the details item, then
we assume it is a detail as well with the list itself being the reveal item
(so an invitation to do something, then click to get hints in list, then click
on each hint). 

j becomes the place where the ol or ul element lives. 

    let j = i+1;
    let stuffInBetween = false;
    let test = lines[j].slice(0,4);
    while ( (test !== '<ol>') && (test !== '<ul>')) {
        j += 1;
        stuffInBetween = true;
        test = lines[j].slice(0,4);
    }
    if (stuffInBetween) { //non list stuff
        p = place += 1;
        ret.push('<div class="blurb">');
        ret.push(` <button @click.stop="togglers[${p}] = ! togglers[${p}]" 
        x-html = "caret( togglers[${p}] )"></button>
         <div>`);
        for (i=i+1; i < j; i += 1) {
            ret.push(lines[i]);
        }
        ret.push('</div></div>');
    }

We are now on the list. The first line is the open list one;

Not sure if we should worry about case of `<li>something</li>`. The last push
of a line that does not exactly match of only having  `<li>` should work. 

    let type = lines[j].slice(1,3);
    if (stuffInBetween) {
        ret.push(`<${type} x-show="togglers[${p}]">`);
    } else {
        ret.push(`<${type}>`);
    }
    let listEnd = `</${type}>`;
    j += 1;
    let line = lines[j];
    let summary = false;
    let q; 
    while (line !== listEnd) {
        if (summary) {
            ret.push(line + `</div></div><div x-show="togglers[${q}]">`);
            summary = false;
        } else if (line === '<li>') {

If the item is just a single bit with no other paragraphs, then we can figure
this out by looking ahead by 2 lines and adding them if the li closure happens
there. 

            if (lines[j+2] === '</li>') {
                ret.push(...lines.slice(j, j+3));
                j += 2;
            } else {
                q = place += 1;
                ret.push(`
                <li><div class="blurb">
                <button @click.stop="togglers[${q}] = ! togglers[${q}]" 
                x-html = "caret( togglers[${q}] )"></button>
                <div> `);
                summary = true;
            }
        } else if (line === '</li>') {
            ret.push('</div></li>');
        } else {
            ret.push(line);
        }
        j+= 1;
        line = lines[j];
    }

    ret.push(listEnd);


i will increment from looping.

    i = j;


[css]()

We want the sub detail list to have no padding


    .blurb > button {
        font-size: 72%;
        padding: 2px 5px;
        margin-right: 1em;    
    } 

    .video iframe {
       width:94vw;
       height:55vw;
    }

    .left, .right {
        height: 96vh;
        position: fixed;
        top: 0px;
        background-color: white;
        z-index: 250;
        width: 70vw;
        padding: 24px;
        overflow-y: auto;
        padding-top: 2vh;
        padding-bottom: 2vh;
        padding-left: 2vw;
        padding-right: 2vw;

    }

    .left {
        left: 0px;
        border-right: whitesmoke 4px solid;
    }

    .right {
        right: 0px;
        border-left: whitesmoke 4px solid;
    }

    .left + .close {
        position: absolute;
        bottom: 1v;
        left: 37vw;
        z-index:260;
    }

    .right + .close {
        position: absolute;
        bottom: 1vh;
        right: 37vw;
        z-index:260;
    }


    .frozen {
        overflow:hidden;
    }
    

    .overlay {
        position:fixed;
        top:0;left:0;right:0;bottom:0;
        background:rgba(255,255,255,0.7);
        z-index:200;
    }

    .blurb {
        display: flex;
        justify-content: flex-start;
        align-items: center;
    }

TODO revisit the positioning of the lists. 


    .blurb + *, .blurb + * > li {
        margin-top:-1em;
    }

    .blurb + * > li > :last-child > :last-child {
        margin-bottom: 1.5em;
    }

    textarea {
        width:clamp(280px, 70vw, 500px);
        height:150px;
    }

    pre {
        border: whitesmoke 2px solid;
        width:clamp(280px, 70vw, 500px);
    }
    
    @media only screen and (max-width: 492px) {
        .left, .right {
            width: 96vw;
            left:0;
            right:unset;
        }

        .left + .close {
            left:48vw;
            right:unset;
        }
       
        textarea, pre {
            width: 92%;
        }

    }



## Slugify

A simple slugification

    (str) => {
        return str.
            trim().
            toLowerCase().
            replace(/[^A-Za-z0-9]/g, '-');
    }


## Make nav


So make path makes the bread crumbs while the rest of this makes the drop
downs for books, chapters, and sections. 

nav is initially hidden to avoid FLOUT. 

    (path) => {

        let ret = '<nav>\n';
        let {prevB, nextB} = nextPrev(path);
        let parlink = makePath(path)[0];
        end = '\n</nav>';
        let lp = links[path];
        if (!lp) {
            lp = links['/'];
        }
        let type = lp.type;
        let downs;
        if (type === 'main') {
            downs = [ ['Books', links[lp.prefix].children],
                ['Chapters', []], 
                ['Sections', []] 
            ];  
        } else if (type === 'book') {
            downs = [ ['Books', links[lp.prefix].children],
                ['Chapters', links[path].children], 
                ['Sections', []] 
            ]; 
        } else if (type === 'chapter') {
            downs = [ 
                ['Books', links[links[lp.prefix].prefix].children ],
                ['Chapters', links[lp.prefix].children],
                ['Sections', links[path].children]
            ];
        } else if (type === 'section') {
            downs = [ 
                ['Books', links[links[links[lp.prefix].prefix].prefix].children ],
                ['Chapters', links[links[lp.prefix].prefix].children ],
                ['Sections', links[lp.prefix].children]
            ];
        }
        downs.push(['Other', [
            _":other"
        ]]);
        const drops = downs.map( ([top, items]) => {
            let mret = `<div class="dropdown" x-data="dropdown" x-init="top='${top}'" x-effect="changeCaret">\n`;
            let cls = items.length ? '' : 'class="empty"';
            mret += `<button ${cls} @click="open = ! open" x-html="caret" :class="open ? 'active' :'' " ></button>\n`;
            mret += `<ul class="menu" x-show="open" x-transition.duration.500ms x-cloak
            @click.outside="open=false">`
            mret += items.map( 
                ([name, path]) => `<li><a class href="${path}.html">${name}</a></li>`).
                join('\n');
            mret += '\n</ul></div>\n';
            return mret;
        }).join('\n');
        let fano = `_":plain fano"`;
        ret += ` <div class="drops">${drops}</div> <div class="prevnext"> ${prevB} ${fano} ${nextB}</div>`;
        ret += end;
        return ret;
    }


[other]()

These are the items in the other dropdown.

    ['Table of Contents', '/toc'],
    ['About', '/about'], 
    ['Resources', '/resources'],
    ['Notes', '/notes'],
    ['Settings', '/settings'],
    ['FAQ', '/faq'],
    ['Index of Content', '/book-index'],
    ['Support','/support']

[dropdown]()

    Alpine.data('dropdown', () => ({
        open: false,
        caret : '',
        top :'',
        
        changeCaret() {
            this.caret = this.top + `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" height="2.5ex" stroke-linejoin="round"><g ${this.open ? '' : 'transform="rotate(-90 12 12)"'}><polyline points="6 9 12 15 18 9"></polyline></g></svg>`;
        }, 

    })) ;

 

[css]()

Styling the nav

    nav {
        border-bottom: 1px solid black;
        display:flex;
        justify-content:space-between;
        flex-wrap:wrap;
        background-color: var(--nav-bg); 
    }

    nav .drops {
        display: inline-flex;
        align-items: center;
    }


    nav .dropdown {
        position:relative;
   
        display: inline-block;
      
    }

    nav .dropdown button {
        display:flex;
        align-items:center;
        font-variant: small-caps;
        margin-right:1px;
        padding: 5px 10px;
        text-align: center;
        border-radius: 0;
        background-color: white;
        border: none; 
    }

    nav .dropdown button, nav .dropdown a {
        font-size:16px;
    }

    nav .dropdown .menu {
        position:absolute;
        list-style:none;
        display:flex;
        flex-direction:column;
        justify-content:flex-start;
        align-items:flex-start;
        width:max-content;
        padding-left:0;
        background-color:white;
        padding:10px;
        border: ridge black 1px;
        margin-top:0;
        filter: drop-shadow(2px 3px 2px);
        z-index:10;
    }

    nav .dropdown a, a:visited {
        text-decoration: none;
        color:black;
        font-variant: small-caps;
        width:100%;
        padding-top:5px;
        padding-bottom:5px;
        display:inline-block;
    }

    nav .dropdown a:hover {
        background-color: var(--pri-bg-faint);
        color: var(--pri-fg-faint);
    }

    nav .empty {
        visibility:hidden;
    }

    .prevnext svg {
        position:relative;
        top: 6px;
    }

    nav .dropdown button.active {
        background-color: var(--pri-bg-moderate);
    }


    @media only screen and (max-width: 492px) {
        nav .dropdown button {
            padding:2px;
            margin-right:0;
        }
    }

    @media only screen and (max-width: 400px) {

        .dropdown button svg {
            display:none;
        }
        nav .dropdown button {
            padding:2px;
            border: solid 1px gray;
            border-radius:4px;
            margin-right:4px;
        }



    }

    @media only screen and (max-width: 360px) {
        nav .prevnext > a[title="Parent"] {
            display:none;
        }

        nav .dropdown .menu {
            position:fixed;
            left:-2vw;
        }

        nav .dropdown button {
            padding:1px;
        }

    }

[plain fano]()

This makes a little svg favicon of a plain pebbles as a little icon.

    <a title="Parent" href="${parlink}.html"><svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0" width="1.5em" viewbox="0 0 600 600">
          <g id="layer1">
             <circle cx="300" cy="350" r="300" fill="#2b5797" />
            <polygon fill="white" stroke="black" stroke-width="12"
                points="50,500 550,500 300,66.98729" />
                <circle cx="300" cy="355.66243" r="144.33756" fill="none"
                stroke="black" stroke-width="12" />
            <line x1="50" y1="500" x2="425" y2="283.49364"
                stroke="black" stroke-width="12" />
            <line x1="550" y1="500" x2="175" y2="283.49364"
                stroke="black" stroke-width="12" />
            <line x1="300" y1="500" x2="300" y2="66.98729"
                stroke="black" stroke-width="12" />
           </g>
           <g fill="#69ceff" stroke="none">
            <circle class="node" cx="50" cy="500" r="40" />
            <circle cx="550" cy="500" r="40"  />
            <circle cx="300" cy="66.98729" r="40"  />
            <circle cx="300" cy="355.66243" r="40"  />
            <circle cx="300" cy="500" r="40"  />
            <circle cx="175" cy="283.49364" r="40" />
            <circle cx="425" cy="283.49364" r="40"  />
          </g>
        </svg></a>


## Make Path

So this makes the path heading. It should be in the form of
`/book/chapter/section`. The actual page one is on does not have a link which
is the reason for the various branches. 


    (path) => {
        const item = _":item";
        const [ignore, book, chapter, section] = path.split('/').map(e=>e.trim());
        let ret = '<ol class="crumbs">';
        const end = '</ol>';
        if (!book) {
            ret += item('mp', 'MathPebbles', ''); 
            ret += end;
            return ['/index', ret];
        }
        ret += item('mp', 'MathPebbles', '/index');
        if (!chapter) {
            ret += item('book', book, ''); 
            ret += end; 
            return ['/index', ret];
        } 
        if (!section) {
            let par = '/'+book;
            ret += item('book', book, par); 
            ret += item('chapter', chapter, '');
            ret += end; 
            return [par, ret];
        } 
        let par = '/'+book;
        ret += item('book', book, par);
        par += '/'+ chapter;
        ret += item('chapter', chapter, par);
        ret += item('section', section, '');
        ret += end; 
        return [par, ret];
    }

[item]()

This creates a nav item. Not sure the form, so wanted to keep it flexible.
Right now, it is a link. 

    (type, name, path) => {
        if (path) {
            return `<li class="crumb ${type}"><a href="${path.toLowerCase()}.html">${name}</a> </li>`;
        } else {
            return `<li class="crumb ${type}">${name}</li>`;
        }
    }

[css]() 

The crumb setup and css was originally from
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav) 

    .crumbs {
        font-variant: small-caps;
    }

    .crumbs {
        list-style-type: none;
        padding-left: 5px;
        padding-top:5px;
        margin:0;

The following bits are a hack to cutoff the breadcrumb if it overflows. I
don't want that to grow. 

        display:block;
        white-space:nowrap;
        overflow: auto;

    }

    .crumb {
        display: inline-block;
    }

    .crumb a::after {
        display: inline-block;
        color: #000;
        content: '>';
        font-size: 80%;
        font-weight: bold;
        padding: 0 3px;
    }

    footer {
        position:fixed;
        bottom:0;
        left:0;
        background-color:whitesmoke;
        width:100%;
        padding-top:4px;
    }




## Progress

This returns the css progress class for a given path. 

    (path) => {
        let progress = links[path]?.progress || 0;
        return 'progress-'+progress;
    }
        

## Next Prev

This creates the next and previous buttons. We need the [listings](listings.md
"load:") loaded.



    (path) => {
        const tr = _":transform";
        const home = '/index';
        let prev, next;   
        if (!links.hasOwnProperty(path) ) { 
            if (path !=='/index') { console.log('no such path:', path); }
            next = '/arithmetic';
            prev = '';
        } else {
            ({prev, next} = ( links[path.trim()] ) );
        }

        if (prev==='/') { prev = '/index'; }

If not prev, then we are on the main page and we have no previous. We add a
div to maintain consistency of the three items. 

        const prevB = prev ? `<a class="prev ${progress(prev)}" href="${prev
        || home}.html" title="${tr(prev)}">_":left"</a> ` : 
            `_":empty"` ;
        const nextB = `<a  class="next ${progress(prev)}" href="${next || home}.html" title="${tr(next)}">_":right"</a>`;
        return {prevB, nextB};
    }

[empty]()

    <a class="prev" aria-hidden="true" style="visibility:hidden;" href="/index.html" title="Ignore">
        _":left"</a> 

[left]()

From https://remixicon.com/


    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"  height="20px"><path fill="none" d="M0 0h24v24H0z"/><path d="M7.828 11H20v2H7.828l5.364 5.364-1.414 1.414L4 12l7.778-7.778 1.414 1.414z"/></svg>

[right]() 

    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"  height="20px"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.172 11l-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2z"/></svg>


[transform]()

This gives the name for the path. 

    (path) => { 
        if (path === '/index') {
            return 'MathPebbles';
        }
        return links[path]?.name || path.slice(1).toUpperCase() || 'MathPebbles' 
    }



[css]() 

    #lotherr {
        display: flex;
        flex-wrap:wrap;
        justify-content: space-between;
    }

    #lotherr sl-icon {
        margin-left: 2px;
        margin-right: 2px;
    }
    
    #lotherr {
        font-variant: small-caps;
    }

## Accordion

This is where we put stuff related to making the accordion style detail stuff. 


[css]()
            
    body > sl-details:not(:last-of-type) {
        margin-bottom: var(--sl-spacing-xx-small);
     }

[js]() 

This is where we do some common behavior on event listening. 


    let nav = $('body > nav');

    let scrollToEl = _":scroll to el";

    const details = $$('body > sl-details');
    details.forEach( el => { 
        el.addEventListener('sl-show', ev => {
            details.forEach( elEv => (elEv.open = ev.target === details) );
            let path = document.location.pathname.split('/').slice(-1)[0].split('.')[0];
            let hash = document.location.hash.slice(1);
            let h2 = $('h2', el);
            let title = h2.innerText;
            console.log(hash, path, el.id, hash!==el.id);

Manage the history state; push state is so that there is no scrolling, but we
do have back/forward behavior. The first if is for the first element. If it is
visible to show, then it should already be at the top so no scroll. The second
is if it is a different element than last shown in which case we scroll.

            if (el.id === path) {
                if (hash.length) { // top default, clear hash
                    history.pushState({}, title, document.location.pathname); 
                }
            } else if (hash !== el.id) {
                history.pushState({},title, document.location.pathname+'#'+el.id);
                setTimeout( () => {
                    scrollToEl(el);
                }, 250);
            } else {
                return; //no action, same element in view
            }


Now we do the scrolling. Since the previous item may be open and then closes,
altering scroll placement, we do a timeout to have that done afterwards.
Hopefully, this also gives context to the user to not be too jarring. 


Now we try to get an item in the newly visible elment focused. 

            let tabby = $('[tabindex]', el);
            if (tabby) {
                tabby.focus();
            } else {
                el.focus();
            }
        });
    });

To have nested details, it was necessary to stop the propagation of the show
events otherwise they would close. Not sure if it is the accordion part. 

    $$('sl-details').forEach( el => {
        el.addEventListener('sl-show', (ev) => ev.stopPropagation());
    });


On initial load, open up the relevant detail from the hash or open up the
default one. 

    let hash = document.location.hash;
    if (hash) {
        let el = $(hash);
        if (el) {
            el.show();
            window.addEventListener('load', () => {
               setTimeout( () => {
                    console.log("scrolling");
                    scrollToEl(el);
                }, 250);
            });
           el.classList.add('currentActive');   
        }
    } else {


We want to open the top level detail if it is a detail. But it could not be in
which case we do nothing. 

        let firstEl = $('nav + *');
        let nn = firstEl.nodeName.toLocaleLowerCase();
        if (nn === 'sl-details') {
            firstEl.show();
        }
        firstEl.classList.add('currentActive');
    }



[scroll to el]()


Positive scrolls up, negative scrolls down. The -6 is just a visual shift of
the heading, kind of a padding. We do smooth so that the use can see what's
going on, even on load. 

    function (el) { 
        let navB = nav.getBoundingClientRect().bottom;
        let h2 = $('h2', el);
        let h2Top = h2.getBoundingClientRect().top;
        scrollBy({top: (h2Top - navB) - 6, behavior:"smooth"});
    }


### Make Fano

This makes the fano symbol which is currently sitting at the end of the
sections. 

    <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0" viewbox="0 0 600 600" id="svg2">
      <defs id="defs4"/>
      <g id="layer1">
        <circle cx="300" cy="355.66243" r="144.33756" fill="none" stroke="black" stroke-width="2"/>
        <polygon fill="none" stroke="black" stroke-width="2" points="50,500 550,500 300,66.98729"/>
        <line x1="50" y1="500" x2="425" y2="283.49364" stroke="black" stroke-width="2"/>
        <line x1="550" y1="500" x2="175" y2="283.49364" stroke="black" stroke-width="2"/>
        <line x1="300" y1="500" x2="300" y2="66.98729" stroke="black" stroke-width="2"/>
        ${fanoSymbols.join('\n')}
      </g>
    </svg>

[css]() 

    .fano {
        display:flex;
        justify-content:center;

    }

    .fano svg {
        width:90vw;
        height:90vw;
        max-width:30em;
        max-height:30em;
    }


This should be the relevant parent circle in the fano. 

    circle.parent {
        fill:#69ceff;
    }


## HTML

This is the head of the page, but leaving some stuff for the bottom. We do
reference the css from [common](common.md "load:")

    <!doctype html>
    <html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width,initial-scale=1.0'>
        <meta name='theme-color' content='#333333'>
        <title> !-!TITLE!-! </title>



My homespun Var binding

        <script type="module">
            import {MP} from _"global js:version";
            window.MP = MP;
            window.$ = MP.$
            window.$$ = MP.$$
            
        </script>

For code editing

        <link href="/r/prism.css" rel="stylesheet" />
        <script>
             window.Prism = window.Prism || {};
		     Prism.manual = true;
         </script>
        <script defer src="/r/prism.js"></script>
        
        <script defer src="/r/codejar.js"></script>

        _"global css:version"


Mathjax  global: MathJax

        <script>
        window.MathJax = {
          svg: {
            fontCache: 'global'
          }
        };
        </script>

        <script type="text/javascript" id="MathJax-script" defer
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
        </script>


JSXGraph  global: JXG

        
        <script type="text/javascript" charset="UTF-8" defer src="/r/jsxgraphcore.js"></script>
        <link rel="stylesheet" type="text/css" href="/r/jsxgraph.css" />

There is also math.js mainly used for high precision arithmetic. 

        <script typ="text/javascript" charset="UTF-8" defer src="/r/math.js"></script>
        <script typ="text/javascript" charset="UTF-8" defer src="/r/decimal.js"></script>
        <script typ="text/javascript" charset="UTF-8" defer src="/r/fraction.js"></script>

        <link rel='manifest' href='manifest.json' crossorigin='use-credentials'>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <link rel="alternate icon" href="/favicon.ico">

        <style>
            .hide  {
                display:none;
            }
            !-!STYLE!-!
        </style>

        !-!HEADER!-!

    </head>
    <body x-data={overlay:false} :class="overlay && 'frozen'"
        @keyup.escape="$el.querySelectorAll('.overlay .close').forEach( (el)=> el.click() )">
    !-!NAV!-!
    !-!BEGIN!-!
    !-!MAIN!-!
    !-!END!-!
    !-!FANO!-!
    !-!FOOTER!-!
    <div class="inputControl"></div>
    <script>
         let m;
         document.addEventListener("DOMContentLoaded", function() {
            const render = _"render";
            const {show, hide } = MP;
            MP.mathHelper(math, Decimal, Fraction);
            math.precision(100);
            MP.makeF(math);

            /*let keyInfo = MP.initKeys({});*/

            !-!SCRIPT!-!

            MP.fun = {
                !-!FUNCTIONS!-!
            };
            
            MP.pebbles = {
                !-!PEBBLES!-!
            };

            MP.code = {
                !-!CODE!-!
            };

            _"setup problems"
        });

    </script>
    </body>
    </html>



# Setup Problems

    const problems = {
        !-!PROBLEMS!-!
    }

TODO: Add stuff for using problems, doing quiz objects or practice objects.     

### Global CSS

    :root {
        --pri-bg : rgb(105, 206, 255);
        --pri-bg-moderate : rgba(105, 206, 255, 0.5);
        --pri-bg-faint : rgba(105, 206, 255, 0.2);
        --pri-fg-faint :rgb(4, 58, 84);
        --nav-bg : whitesmoke;
    }

    [x-cloak] { display: none !important; }
    
    body {
        max-width: 80em;
        margin-left: 4px;
        margin-right: 4px;

The top margin being 0 helps the nav not have a gap. We need to have a full
page width on the bottom to have it be able to scroll up. 

        margin-top: 0;
        padding-bottom: 120vh;
    }


This styles the header bit

    body > nav {
        position: sticky;
        top: 0;
        width: 100%;
        background-color: white; /*rosybrown;  /*#33007d; purple*/
        z-index: 2;
    }


To give space for underline of number, we increase the line height a bit. 

    p {
        line-height: 1.2;
    }

    sl-input {
        width: 20ch;
    }

Specifying width otherwise the explore buttons don't line up. 

    .section h2, h2.with-explore {
        width:min(90vw, 50em);

grid to put the explore buttons on the right and have long text drop down. To
keep the explore button from growing, we give it a height of 1em.

        display: grid;
        grid-template-columns: 1fr auto;
    }


TODO: consolidate all of this (replace .explore with .button). 

    .top button, .top a.button, .section h2 button, .explore, .explore:link, .explore:visited {
      background-color: var(--pri-bg); 
      font-size:initial;
      border:none;
      color: black;
      padding: 5px 10px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-variant: small-caps;
      border-radius:4px;
    }
    
    h2.with-explore .explore {
      height: 1em;
    }
    .section h2 button {
        font-family: inherit;
        font-weight: inherit;
        font-size:60%;
        height:1.7em;
        border:none;
    }

    .explore:visited {
        filter:brightness(80%);
    }

    .top button:hover, .top button:active, .top button:focus, .explore:hover, .explore:active, .explore:focus {
      filter: drop-shadow(3px 3px 2px);
      outline:none;
    }

    .video button {
        font-size: 72%;
        padding: 2px 5px;
    }


This simulates the detail block for the non-detail stuff on the pages: (now
not using the detail so using class section for non-plain, so just adding it). 

    .top {
        padding-left: 1em;
        border: 1px solid var(--sl-color-gray-200);
        border-radius: 5px;
        padding-right:1em;
    }

    .top + .top { 
        margin-top: 5px;
    }

Safari requires fixed positioning for the foreign object so we make a class
for that.

    .safari-fixed {
        position:fixed;
    }

    @media only screen and (max-width:440px) {
        .safari-fixed {
            top: -10px;
            left: -7px;
        }
    }

    _"make path:css"
    _"next prev:css"
    _"accordion:css"
    _"shoelace full:css"
    _"common::css"
    _"make nav:css"
    _"make fano:css"

    _"xdata footer css"
        

    
[../public/r/global-2.css](# "save:")

[version]() 

    <link rel='stylesheet' href='/r/global-2.css'>


### Global JS

    
    import Alpine from '/r/alpine.mjs'

    _"common::js"


    document.addEventListener("DOMContentLoaded", function() {

        window.render = _"render";

        _"accordion:js"

        _"common::content loaded"

        _"alpine"

    });


[../public/r/global-2.mjs](# "save:")
    
[version]()

    '/r/global-2.mjs'
            

#### Render

This is a short wrapper for doing a render

    function render (text, par, options) {
        options ??= {display:false}
        let out = MathJax.tex2svg(text, options);
        if (par) {
            while (par.firstChild) {
              par.removeChild(par.firstChild);
            }
            par.append(out);
        }
        return out; 
    }




## Alpine

This is where we put all the Alpine related code. 


    _"make nav:dropdown"

    let dataStores = window.dataStores = {};
    let inputTypes = window.inputTypes = _"input types";

    let methods = _"make alpine methods";

This is for the main section which hosts lots of subsections too. 

    Alpine.data('section', () => {
        const ret= {...MP.pebbles, ...methods};
        ret.open = false;
        ret.footCount = 0;
        ret.togglers = [];
        return ret;
    });

Code needs its own scope and has a variety of methods so this creates that
independent context.

    Alpine.data('code', () => {
        let jar, editor, title, original;
        const ret = { ...MP.code, _":code"};
        ret.log = [];
        ret.out = '';
        return ret;
    });


    window.Alpine = Alpine
    Alpine.start()


[show]()

To avoid flout, I find it necessary to hide some stuff. This cleans it up. 

    $$('.menu').forEach( el=> show(el) );
    

[code]()


This imports the code from the to-be-hidden code block into the textarea. 

    start (el, t)  {
        title = t;
        console.log('el', el, t);
        jar = CodeJar(el, Prism.highlightElement);
        let origCode = el.parentElement.lastElementChild.firstElementChild;
        origCode.classList.add('hide');
        original = origCode.textContent;
        this.reset();
    },
    reset () {
        jar.updateCode(original);
        this.log  = [];
        this.out = '';
    },
    run () {
        this.log = [];
        this.out = '';
        let {pre = '', post = '' } = this;
        let userCode = jar.toString();
        try {
            let log = (...args) => this.log.push(...args);
            let out = (str) => {this.out = str};
            let vars = this.vars.map( name => `let ${name} =
            this.${name};`).join('\n'); 
            let str = vars + '\n' + pre + '\n' + userCode + '\n' + post;
            console.log(str);
            eval(str);
        } catch(e) {
            this.log.push(e);
        }
    },
    save () {
    },
    restore () {

    },

[junk]()



     imp (el) {
        let ta = el.firstElementChild.firstElementChild;
        let code = el.lastElementChild;
        code.classList.add('hide');
        ta.focus();
        ta.selectionStart = 0; 
        ta.selectionEnd = ta.value.length;
        console.log(ta.selectionStart, ta.selectionEnd);
        document.execCommand('insertText', false, code.firstElementChild.innerText);
        this.log = [];
        this.out = '';
        this.updateCode(ta);
     },
     run (el) {
        this.log = [];
        this.out = '';
        let {pre = '', post = '' } = this;
        try {
            let log = (...args) => this.log.push(...args);
            let out = (str) => {this.out = str};
            let vars = this.vars.map( name => `let ${name} =
            this.${name};`).join('\n'); 
            let str = vars + '\n' + pre + '\n' + el.firstElementChild.value + '\n' + post;
            console.log(str);
            eval(str);
        } catch(e) {
            this.log.push(e);
        }
    }, 
    save (el) {
        //some kind of name grabbing for saving
        //save el.firstElementChild.value;
    },
    restore (el) {
        // some kind of selection of saved versions
        // el.firstElementChild.value = saved text
    },
    noop () { },
    checkTab(ta, spaces) {
        let code = ta.value;
        let start = ta.selectionStart;
        let spaceStr = ' '.repeat(spaces);

The execCommand comes from https://stackoverflow.com/a/44473352  It is
deprecated, but if it works, its cool. 

        document.execCommand('insertText', false, spaceStr);
        this.updateCode(ta);
      },



### Make alpine methods

This is where we stick a bunch of common alpine methods.

    {
        _":mathout",
        _":mathParse",
        empty : () => '', // if  you need an empty string 
        pass : (v) => v,  //displays nothing, but does pass through to store
        store : function (v, name) {
            return this[name] = v; 
        },
        innerHTML (val, par) {
            par.innerHTML = val;
        },
        me (name) {
            dataStores[name] = this;
            this.me = name;
        },
        caret (open=false, text='') {
            return  text + ` <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" height="2.5ex" stroke-linejoin="round"><g ${open ? '' : 'transform="rotate(-90 12 12)"'}><polyline points="6 9 12 15 18 9"></polyline></g></svg>`;
        },
        _"toggle Input", 
    }

[mathout]()

This calls the math renderer. The return of MathJax are elements, not html
strings so this is why we are doing it with el appending etc. 

    mathOut (value, el) {
        let options = {display:false};
        if (el.tagName === 'DIV') {
            options.display = true;
        }
        render(math.spacedNumber(value), el, options);
        return value;
    }

[mathParse]()

    mathParse (value, el) {
        let {type} = el.dataset;
        try {
            return this[name]=math[type](value);
        } catch (e) {
            console.error(type, value, e, el);
        }
    }


### Toggle Input

This is the function that is called to toggle inputting changes to the input
variables. This uses the data-type attribute to figure out what kind of input
is appropriate. It pops up the input element in the footer. The id of the
encapsulating div for the input is iname where name is the name of the input.  

    toggleInput(el) {
        let {name, type} = el.dataset;
        let footer = $('.footer', el.closest('[x-data]'));
        let iname = 'i' + name;
        let inp = $('#' + iname, footer);
        if (inp) { //already exists, just toggle
            $('.toggle', inp).click();
            return;
        }

Make input if we get to here. 

We have this odd way of constructing because innerHTML assignment with alpine
seemed to create two click handlers. By cloning and appending, it resets so
only one gets assigned. 

        let div = document.createElement('div');
        let html = inputTypes[type]?.(name, this);  
        div.innerHTML= html;
        footer.appendChild(div.children[0].cloneNode(true));
    }

### Input types

This is where we create the various input types. They are: 

* bignum.  This add or subtracts based on the power of 10 selected.  
    
---

    {
    _"decimal",
    
    }

### Decimal 

    decimal (name, store) {
        let iname = 'i'+name; //input string
        let ename = 'e'+name; //actual power value
        let pname = 'p'+name; //power string for input
        let tname = 't'+name; //toggle visibility
        store[iname] = store[name].toString();
        store[ename] = 1;
        store[pname] = 0;
        store[tname] = true;
        let html = `_":html"`;
        return html;
    }

[html]()

This is the html 

    <li id="i${name}" x-show = "t${name}">
    <div class="primary" >
        <button @click="${name} = ${name}.sub(${ename})">-</button>
        <input type="text" @change="${name} = math.decimal($el.value)"
            x-effect="$el.value = ${name}.toString()" ></input>
        <button @click="${name} = ${name}.add(${ename}) ">+</button>
    </div>

    <div class="exponent">
        <button @click="p${name} = p${name} - 1">_</button>
        <span>1E</span>
        <input x-model.number="p${name}" x-effect="e${name} = Math.pow(10, p${name})"></input>
        <button @click="console.log('hey'); p${name} = p${name} + 1" >^</button>
    </div>


This bit toggle the open or closed, but it also increments/decrements footCount
depending on whether the toggle 

    <div class="controls">
       <button class="toggle" @click="t${name} = ! t${name}"
       x-effect="t${name} ? footCount++ : footCount--" >X</button>
    </div>

    </li>


### xdata footer css

Similar to the bottom footer, but shifted up. 

    .footer {
        position: sticky;
        bottom: 26px;
        background-color: whitesmoke;
        width: 100%;
        z-index:20;
        lisstyle : none;
        padding:0;
    }

    .footer li {
        display:flex;
        justify-content: space-between;
    }

    .footer input {
        border: 1px solid var(--pri-bg-moderate);
    }
    
    .footer .exponent input {
        width: 3em;
    }

    .footer button {
        background-color: var(--pri-bg-moderate);
        border: none;
        border-radius: 4px;
    }

    @media only screen and (max-width: 400px) {
        .footer .primary input {
            width:6em;
        }

    }

### xactive

This takes in a boolean expression and will add or remove the active class
depending on true or false, respectively. 


NOT NEEDED due to bind directive!  :class="bool ? 'active' : ''

    Alpine.directive('active', (el, { expression }, { evaluateLater, effect }) => {
        let callbool = evaluateLater(expression)

        effect(() => {
            callbool(bool => {
                if (bool) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
        });
    });


