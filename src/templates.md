# Templates

This is the source for the templates for our various types of pages. 

There are three types, excluding the home page (code that up separately)


## Page

This generates the pages. 

A section is run by tab panels for subections. It starts with an intro
overview panel, but after that, it is individual to each page. Each panel
should correspond to a hashing of the url which gets autogenerated. 

Use as `_"header|page type, path, title, _'intro', tab title, _'tab1|md', tab title, _'tab2', ..."`. If you need to add
per page css or js, then sub in `/*STYLE*/` or `//SCRIPT` after. In intro, the
first line should be a path while the second line should be a title. 

Each tab should start off with the first line as the tab name which also gets
slugified as a hash upon switching to the tab. 

The current idea of the intro is that when a tab is clicked( or hashed to),
then the intro collapses with the title (h2) becoming small and an expand
button being placed there alongside; it is sticky to the header. Implemented
for now as a details. 

The intro part should have the first line as a path, then the second line as
the title. 

We are using the standard md for markdown. It also handles some latex stuff.
By adding to a [prepost](https://github.com/jostylr/literate-programming/blob/master/project.md#md)


    function page (text, args) {
        const links =  _"listings::links";
        const slugify = _"slugify";
        const progress = _"progress";
        const makePath = _"make path";
        const makeNav = _"make nav";
        const nextPrev = _"next prev";
        const base = `_"html"`;
        let pieces = base.split('!-!');
        const replace = {};
        let path = args[0];

The path should start with a slash, but easy to forget. 

        if (path[0] !== '/') {
            path = '/' + path;
        }
        replace.NAV = makeNav(path);
        replace.TITLE = links[path]?.name ?? 'MathPebbles'; //index is not in the listings
        _":populate replace"
        
        let main = '';
        _":details"
        replace.MAIN = main;

        replace.FOOTER = nextPrev(path);
        
        let ret =  pieces.
            map( key => {
                if (key.match(/^[A-Z]+$/)) {
                    return replace[key] || '';
                } else {
                    return key;
                }
            }).
            join('\n');

        return ret;
    }


[page](# "define:")

[temp.js](# "save:")


[populate replace]()

So the text should have `!-NAME\n` stuff and the Name is the key and the stuff
until the next one 

    let indpr;
    let key = '';
    while (  (indpr = text.indexOf('!-')) !== -1) {
        if (key) {
            replace[key] = text.slice(0, indpr);
        }
        text = text.slice(indpr+2);
        let indnew = text.indexOf('\n');
        key = text.slice(0, indnew).trim().toUpperCase();
        text = text.slice(indnew+1);
    }
    if (key) {
        replace[key] = text;
    }




[details]() 

This is the generator of the details. The stuff comes in pairs with the first
one being either a section name only or an array with the first element being
the section name and the second one being a path for the Explore button. 

   
    let n = args.length;
    for (let i = 0; i < n; i+=2)  {
        let lpath = args[i];
        let item = links[lpath];
        let name, href;
        if (item) {
            name = item.name;
            href = lpath;
        } else if (lpath==='/index') {
            name = 'MathPebbles';
        } else {
            name = lpath;
        }
        let heading; 
        if ((i !== 0) && (href)) {  // not intro
            heading = `    <h2 class="with-explore"><span class="heading">${name}</span>`+
                `<a class="explore" href="${href}.html">` +
                `Explore </a></h2> \n\n` ; 
        } else {
            heading = `<h2>${name}</h2>`;
        }
        const body = args[i+1].trim();
        const [preview, full] = body.split('<p>!-</p>').map( e => e.trim());
        main += `<sl-details id="${slugify(name)}">
            <div slot="summary">
                ${heading}
                ${preview}
            </div>
            ${full || ''}
            </sl-details>`;
    }



## Slugify

A simple slugification

    (str) => {
        return str.
            trim().
            toLowerCase().
            replace(/[^A-Za-z0-9]/g, '-').
    }


## Make nav


So make path makes the bread crumbs while the rest of this makes the drop
downs for books, chapters, and sections. 

nav is initially hidden to avoid FLOUT. 

    (path) => {

        let ret = '<nav class="crumbs">\n';
        ret += makePath(path);
        end = '\n</nav>';
        let lp = links[path];
        if (!lp) {
            lp = links['/'];
        }
        let type = lp.type;
        let downs;
        if (type === 'main') {
            downs = []; 
        } else if (type === 'book') {
            downs = [ ['Books', links[lp.prefix].children] ]; 
        } else if (type === 'chapter') {
            downs = [ 
                ['Books', links[links[lp.prefix].prefix].children ],
                ['Chapters', links[lp.prefix].children]
            ];
        } else if (type === 'section') {
            downs = [ 
                ['Books', links[links[links[lp.prefix].prefix].prefix].children ],
                ['Chapters', links[links[lp.prefix].prefix].children ],
                ['Sections', links[lp.prefix].children]
            ];
        }
        const drops = downs.map( ([top, items]) => {
            let mret = '<sl-dropdown>\n';
            mret += `<sl-button slot="trigger" caret>${top}</sl-button>\n`;
            mret += items.map( 
                ([name, path]) => `<sl-button class="hide" href="${path}.html">${name}</sl-button>`).
                join('\n');
            mret += '\n</sl-dropdown>\n';
            return mret;
        }).join('\n');
        ret += `<div>${drops}</div>`;
        ret += end;
        return ret;
    }

## Make Path

So this makes the path heading. It should be in the form of
`/book/chapter/section`. The actual page one is on does not have a link which
is the reason for the various branches. 


    (path) => {
        const item = _":item";
        const [ignore, book, chapter, section] = path.split('/').map(e=>e.trim());
        let ret = '<ol>';
        const end = '</ol>';
        if (!book) {
            ret += item('mp', 'MathPebbles', ''); 
            ret += end;
            return ret;
        }
        ret += item('mp', 'MathPebbles', '/index');
        if (!chapter) {
            ret += item('book', book, ''); 
            ret += end; 
            return ret;
        } 
        if (!section) {
            ret += item('book', book, '/'+book); 
            ret += item('chapter', chapter, '');
            ret += end; 
            return ret;
        } 
        ret += item('book', book, '/'+book); 
        ret += item('chapter', chapter, '/'+book + '/' + chapter);
        ret += item('section', section, '');
        ret += end; 
        return ret;
    }

[item]()

This creates a nav item. Not sure the form, so wanted to keep it flexible.
Right now, it is a link. 

    (type, name, path) => {
        if (path) {
            return `<li class="crumb ${type}"><a href="${path.toLowerCase()}.html">${name}</a> </li>`;
        } else {
            return `<li class="crumb ${type}">${name}</li>`;
        }
    }

[css]() 

The crumb setup and css was originally from
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav) 

    .crumbs {
        border-bottom: 1px solid black;
        font-variant: small-caps;
        display:flex;
        justify-content:space-between;
        flex-wrap:wrap;
    }

    .crumbs ol {
        list-style-type: none;
        padding-left: 5px;
    }

    .crumb {
        display: inline-block;
    }

    .crumb a::after {
        display: inline-block;
        color: #000;
        content: '>';
        font-size: 80%;
        font-weight: bold;
        padding: 0 3px;
    }

    .crumbs > div {
        display:inline-flex;
        justify-content: flex-end;
        flex-wrap:wrap;
    }

    .crumbs sl-dropdown {
        margin-right:10px;
    }

    sl-dropdown sl-button {
        width:100%
    }

[junk]()

long ones did not look right

    .crumbs sl-button {
        width:150px;  
    }




## Progress

This returns the css progress class for a given path. 

    (path) => {
        let progress = links[path]?.progress || 0;
        return 'progress-'+progress;
    }
        

## Next Prev

This creates the next and previous buttons. We need the [listings](listings.md
"load:") loaded.



    (path) => {
        const tr = _":transform";
        const home = '\index';
        let prev, next;   
        if (!links.hasOwnProperty(path) ) { 
            console.log('no such path:', path); 
            next = '\arithmetic';
            prev = home;
        } else {
            ({prev, next} = ( links[path.trim()] ) );
        }
        const prevB = `<sl-button class="prev ${progress(prev)}" href="${prev || home}.html">
            <sl-icon name="arrow-left" stye="font-size:20px;"></sl-icon>${tr(prev)}
            </sl-button>`;
        const nextB = `<sl-button class="next ${progress(prev)}" href="${next || home}.html">${tr(next)}<sl-icon name="arrow-right" stye="font-size:20px;"></sl-icon></sl-button>`;
        return `<footer>${prevB} _":middle" ${nextB}</footer>`;
    }

[transform]()

This gives the name for the path. 

    (path) => links[path]?.name || 'MathPebbles' 


[middle]()

This gives the middle pages in the footer: About, FAQ, Settings, Site Map


    <sl-dropdown>
        <sl-button slot="trigger" caret>Non-Mathy Stuff</sl-button>
        <sl-button href="/about.html">About</sl-button>
        <sl-button href="/faq.html">FAQ</sl-button>
        <sl-button href="/support.html">Support</sl-button>
        <sl-button href="/settings.html">Settings</sl-button>
        <sl-button href="/toc.html">Table of Contents</sl-button>
        <sl-button href="/book-index.html">Index of Content</sl-button>
    </sl-dropdown>


[old transform]()

This transforms the path info into human pleasing ideas. 

    (text) => {
        if (!text) {return ''};
        return text.
            slice(1).
            replace(/\//g, ' > ').
            replace(/\-\-/g, ', ').
            replace(/\-/g, ' ');
    }


[css]() 

    footer {
        display: flex;
        flex-wrap:wrap;
        justify-content: space-between;
    }

    footer sl-icon {
        margin-left: 2px;
        margin-right: 2px;
    }
    
    footer {
        font-variant: small-caps;
    }

## Accordion

This is where we put stuff related to making the accordion style detail stuff. 


[css]()
            
    body > sl-details:not(:last-of-type) {
        margin-bottom: var(--sl-spacing-xx-small);
     }

[js]() 

This is where we do some common behavior on event listening. 


    const details = $$('body > sl-details');
    details.forEach( el => { 
        el.addEventListener('sl-show', ev => {
            details.forEach( elEv => (elEv.open = ev.target === details) );
            let path = document.location.pathname.split('/').slice(-1)[0].split('.')[0];
            let hash = document.location.hash.slice(1);
            console.log(hash, path, el.id);
            if (el.id === path) {
                if (hash.length) {
                    document.location.hash = '';
                }
            } else if (hash !== el.id) {
                document.location.hash = el.id;
            }
        });
    });

    let hash = document.location.hash;
    if (hash) {
        $(hash).show();
    } else {
        details[0].show();
    }



## HTML

This is the head of the page, but leaving some stuff for the bottom. We do
reference the css from [common](common.md "load:")

    <!doctype html>
    <html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width,initial-scale=1.0'>
        <meta name='theme-color' content='#333333'>
        <title> !-!TITLE!-! </title>
    
Shoelaces. Load this first so submodules can load while others load. Found if
katex and jsxgraph were first, then they block loading of elements. 

        <link rel="stylesheet" href="/r/shoelace/shoelace.css">
        <script type="module" src="/r/shoelace/shoelace.esm.js"></script>

My homespun Var binding

        <script type="module">
            import {MP} from _"global js:version";
            window.MP = MP;
            window.$ = MP.$
            window.$$ = MP.$$
            
        </script>


        _"global css:version"


Katex  global: katex

        <link rel="stylesheet" href="/r/katex.css">
        <script defer src="/r/katex.js" ></script>



JSXGraph  global: JXG

        
        <script type="text/javascript" charset="UTF-8" defer src="/r/jsxgraphcore.js"></script>
        <link rel="stylesheet" type="text/css" href="/r/jsxgraph.css" />

There is also math.js mainly used for high precision arithmetic. 

        <script typ="text/javascript" charset="UTF-8" defer src="/r/math.js"></script>


        <link rel='manifest' href='manifest.json' crossorigin='use-credentials'>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <link rel="alternate icon" href="/favicon.ico">

        <style>
            .hide  {
                display:none;
            }
            !-!STYLE!-!
        </style>

        !-!HEADER!-!

    </head>
    <body>
    !-!NAV!-!
    !-!BEGIN!-!
    !-!MAIN!-!
    !-!END!-!
    !-!FOOTER!-!
    <script>
         let m;
         document.addEventListener("DOMContentLoaded", function() {
            const {link, Var, show, hide } = MP;
            MP.mathSub(math);
            math.config({number:'BigNumber'});
            let keyInfo = MP.initKeys();
            //let makeScaledNumber = MP.initScaledNumber(math, JXG, keyInfo.keys); 
            let [makeTypedInput, types] = MP.initMakeTypedInput(math, JXG, keyInfo.keys); 
  
            !-!SCRIPT!-!
            
        });

    </script>
    </body>
    </html>


### Global CSS


    body {
        max-width: 80em;
        margin-left: auto;
        margin-right: auto;
    }

    sl-input {
        width: 20ch;
    }

Specifying width otherwise the explore buttons don't line up. 

    h2.with-explore {
        width:min(90vw, 50em);
        display:flex;
        justify-content: space-between;
        flex-wrap:wrap;
    }

    .explore:link, .explore:visited {
      background-color: #69ceff;
      font-size:80%;
      color: black;
      padding: 5px 10px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-variant: small-caps;
      border-radius:4px;
    }

    .explore:hover, .explore:active {
      filter: drop-shadow(3px 3px 2px);
    }

    _"make path:css"
    _"next prev:css"
    _"accordion:css"
    _"common::css"
        

    
[../public/r/global-1.css](# "save:")

[version]() 

    <link rel='stylesheet' href='/r/global-1.css'>


### Global JS

    
    
    _"common::js"


     document.addEventListener("DOMContentLoaded", function() {
        $$('.crumbs  sl-button' ).forEach(el => el.classList.remove('hide'));

        _"accordion:js"

        $$('a.explore').forEach( (el) => {
            el.addEventListener( 'click', (ev) => ev.stopPropagation()); 
        });
    });


[../public/r/global-1.mjs](# "save:")
    
[version]()

    '/r/global-1.mjs'
            


# Previously useful Abandoned now

## Section Example

This is an example to try out 


[../public/section.html](# "save | page algebra/lines/shortest-distance,_':intro|md', Distance, _':section 1|md', Angles,_':section 2|md'" )

[intro]() 

    This is a sample intro lines

[section 1]()

    The shortest distance between two lines is ...

[section 2]( )

    
    Diffrent cool shapes


## Book Example

This is just the same as the section example except it is a book. 

    _":pieces | page  /algebra/lines, _':intro|md', 
        /algebra/lines/shortest-distance, _':section 1|md', 
        /algebra/lines/circles--angles--and-trianges, _':section 2|md' "


[../public/book.html](# "save" )


[pieces]()

    !- style
    _":style"
    !- script
    _":script"


[style]()

This is an example to try out 


[script]()
        
    console.log('hey');


[intro]() 

    This is a sample intro to lines (preview)

    !-
    
    This should be a longer bit expanded. 


[section 1]()


    The shortest distance between two points is given by the straight line
    between them. 

    !-

    Walk from there to here in the minimu of steps...

    What are the implications of this ...

    Read more in the chapter [Shortest
    Distance](/algebra/lines/shortest-distance). 

[section 2]( )

 
    From the shortest distance, we get a circle. From a circle, we get an
    angle. And with three lines, we get three angles whose figure is called a
    triangle. 

    Read more in the chapter [Circles, Angles, and
    Triangles](/algebra/lines/circles--angles--and-triangles). 

    !-

    What are all the places I can get to that are exactly 1 mile away from
    where I am now? 

    ....


  


