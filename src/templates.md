# Templates

This is the source for the templates for our various types of pages. 

There are three types, excluding the home page (code that up separately)


## Page

This generates the pages. 

A section is run by tab panels for subections. It starts with an intro
overview panel, but after that, it is individual to each page. Each panel
should correspond to a hashing of the url which gets autogenerated. 

Use as `_"header|page type, path, title, _'intro', tab title, _'tab1|md', tab title, _'tab2', ..."`. If you need to add
per page css or js, then sub in `/*STYLE*/` or `//SCRIPT` after. In intro, the
first line should be a path while the second line should be a title. 

Each tab should start off with the first line as the tab name which also gets
slugified as a hash upon switching to the tab. 

The current idea of the intro is that when a tab is clicked( or hashed to),
then the intro collapses with the title (h2) becoming small and an expand
button being placed there alongside; it is sticky to the header. Implemented
for now as a details. 

The intro part should have the first line as a path, then the second line as
the title. 

We are using the standard md for markdown. It also handles some latex stuff.
By adding to a [prepost](https://github.com/jostylr/literate-programming/blob/master/project.md#md)


    function page (text, args) {
        const links =  _"listings::links";
        const slugify = _"slugify";
        const progress = _"progress";
        const makePath = _"make path";
        const makeNav = _"make nav";
        const nextPrev = _"next prev";
        const shoelacify = _"shoelace full";
        const base = `_"html"`;
        let pieces = base.split('!-!');
        const replace = {};
        let path = args[0];

The path should start with a slash, but easy to forget. 

        if (path[0] !== '/') {
            path = '/' + path;
        }
        replace.NAV = makeNav(path);
        replace.TITLE = links[path]?.name ?? 'MathPebbles'; //index is not in the listings
        _":populate replace"
        
        let main = '';
        _":details"
        replace.MAIN = main;

        replace.FOOTER = nextPrev(path);
        
        let ret =  pieces.
            map( key => {
                if (key.match(/^[A-Z]+$/)) {
                    return replace[key] || '';
                } else {
                    return key;
                }
            }).
            join('\n');

        return ret;
    }


[page](# "define:")

[temp.js](# "save:")


[populate replace]()

So the text should have `!-NAME\n` stuff and the Name is the key and the stuff
until the next one 

    let indpr;
    let key = '';
    while (  (indpr = text.indexOf('!-')) !== -1) {
        if (key) {
            replace[key] = text.slice(0, indpr);
        }
        text = text.slice(indpr+2);
        let indnew = text.indexOf('\n');
        key = text.slice(0, indnew).trim().toUpperCase();
        text = text.slice(indnew+1);
    }
    if (key) {
        replace[key] = text;
    }




[details]() 

This is the generator of the details. The stuff comes in pairs with the first
one being either a section name only or an array with the first element being
the section name and the second one being a path for the Explore button. 

   
    let n = args.length;
    for (let i = 0; i < n; i+=2)  {
        let lpath = args[i];
        let item = links[lpath];
        let name, href;
        if (item) {
            name = item.name;
            href = lpath;
        } else if (lpath==='/index') {
            name = 'MathPebbles';
        } else {
            name = lpath;
        }
        let heading; 
        if ((i !== 0) && (href)) {  // not intro
            heading = `    <h2 class="with-explore"><span class="heading">${name}</span>`+
                `<a class="explore" href="${href}.html">` +
                `Explore </a></h2> \n\n` ; 
        } else {
            heading = `<h2>${name}</h2>`;
        }
        const body = args[i+1].trim();
        let [preview, full] = body.split('<p>!-</p>').map( e => e.trim());
        full = shoelacify(full || ''); 
        main += `<sl-details id="${slugify(name)}">
            <div slot="summary">
                ${heading}
                ${preview}
            </div>
            ${full || ''}
            </sl-details>`;
    }



## Shoelace full

This is a complicated bit of code where we use our own little crappy DSL to
slot in elements of the shoelace variety (and maybe others too) 

Here is the lingo. All of the special stuff is of the form !NAME. Some have
some verbage on that same line, most don't. Many consume stuff in subsequent
lines until some ending tag. 

* PEBBLE  Single line, takes in a pebble name. The code to create it is found
  elsewhere. 
* VIDEO Single line, two pieces: a url with no space and then the rest is a
  title
* PROOF: whatever for a proof environment.  QED.
* DETAILS: Expects a list where per item first paragraph is the summary and
  the rest are the details. Each list item is its own detail. For now, no
  sublists please! If you need sublists, use the longer form SUMMARY/DETAIL.
  Ends with OVER.
* SUMMARY: (summary stuff) DETAIL: (detail stuff) DONE.  A standalone detail
  item
* PROGRAM: whatever for a program environment. STOP.
* CODE name: starting code block  SOLUTION: Some explanatory text and a code
  block to sub in for the solution. END.

---

    function shoelacify (text) {
        let reg = /\!([A-Z]+)(.*)$/;
        let lines = text.split('\n');
        let ret = [];
        let n = lines.length;
        let i;
        for (i = 0; i < n; i+= 1) {
            let line = lines[i];
            if (line.slice(0,4) === '<p>!') {
                let match = line.match(reg);
                let type = match?.[1] || '';
                let end = (match?.[2] || '').
                    trim().
                    slice(0, -4); //slice is to get rid of closing p element

                switch (type) {
                case 'PEBBLE' : {
                    let id = end.trim();
                    ret.push('<div class="pebble" id="'+id+'"></div>');
                break; }
                case 'VIDEO':
                    end = end.trim();
                    let ind = end.indexOf(' ');
                    let url = end.slice(0, ind);
                    let title = end.slice(ind+1);
                    ret.push('<sl-details summary="Video: '+title+'"><iframe width="560" height="315" src="'+url+'" title="YouTube video player" frameborder="0"  allowfullscreen></iframe></sl-details>');
                break;
                case 'PROOF':
                    ret.push('<button type="button" class="explore open-drawer">Proof</button><sl-drawer class="proof" placement="left">');
                break;
                case 'QED':
                    ret.push('<button class="explore close-drawer" slot="footer">Close</button></sl-drawer>');
                break;
                case 'DETAILS':
                    _":details"
                break;
                case 'SUMMARY':
                    ret.push('<sl-details><div slot="summary">');
                break;
                case 'DETAIL': {
                    ret.push('</div>');
                break; }
                case 'DONE':
                    ret.push('</sl-details>');
                break;
                case 'PROGRAM' :
                    ret.push('<button type="button" class="explore open-drawer">Program</button><sl-drawer placement="right" class="program">');
                break;
                case 'STOP':
                    ret.push('<button class="explore close-drawer" slot="footer">Close</button></sl-drawer>');
                break;
                case 'CODE': {
                    let id = end.slice(0,-1).trim();
                    ret.push('<sl-details class="code-block" data-id="'+id+'"><div class="try-code code" slot="summary">');
                break; }
                case 'SOLUTION':
                    ret.push('</div><div class="solution-code code" >');
                break;
                case 'END':
                    ret.push('</div></sl-details>');
                break;
                default: 
                    ret.push(line);
                }
            } else {
                ret.push(line);
            }
        }

        return ret.join('\n');
    }

[details]()

This is the one complicated bit. The details takes a list and converts each
item into a detail object. The first paragraph becomes the summary (slot =
summary). If a list is not the thing immediately after the details item, then
we assume it is a detail as well with the list itself being the reveal item
(so an invitation to do something, then click to get hints in list, then click
on each hint). 

    let j = i+1;
    let stuffInBetween = false;
    let test = lines[j].slice(0,4);
    while ( (test !== '<ol>') && (test !== '<ul>')) {
        j += 1;
        stuffInBetween = true;
        test = lines[j].slice(0,4);
    }
    if (stuffInBetween) { //non list stuff
        ret.push('<sl-details><div slot="summary">');
        for (i=i+1; i < j; i += 1) {
            ret.push(lines[i]);
        }
        ret.push('</div>');
    }

We are now on the list. The first line is the open list one;

Not sure if we should worry about case of `<li>something</li>` Experiments
suggest that should not happen. 
    

    ret.push(lines[j]);
    let listEnd = '</' + lines[j].slice(1);
    j += 1;
    let line = lines[j];
    let summary = false;
    while (line !== listEnd) {
        if (summary) {
            ret.push(line + '</div>');
            summary = false;
        } else if (line === '<li>') {
            ret.push('<li><sl-details><div slot="summary">');
            summary = true;
        } else if (line === '</li>') {
            ret.push('</sl-details></li>');
        } else {
            ret.push(line);
        }
        j+= 1;
        line = lines[j];
    }

    ret.push(line);

    if (stuffInBetween) {
        ret.push('</sl-details>');
    }

    i = j;


[css]()

We want the sub detail list to have no padding

    sl-details ol, sl-details ul {
        padding-left:2px;
    }

    sl-drawer{
        --size : clamp(200px, 90vw, 600px);
    }

    sl-drawer[placement=left] [slot=footer] {
        float:left;
    }


## Slugify

A simple slugification

    (str) => {
        return str.
            trim().
            toLowerCase().
            replace(/[^A-Za-z0-9]/g, '-');
    }


## Make nav


So make path makes the bread crumbs while the rest of this makes the drop
downs for books, chapters, and sections. 

nav is initially hidden to avoid FLOUT. 

    (path) => {

        let ret = '<nav class="crumbs">\n';
        ret += makePath(path);
        end = '\n</nav>';
        let lp = links[path];
        if (!lp) {
            lp = links['/'];
        }
        let type = lp.type;
        let downs;
        if (type === 'main') {
            downs = []; 
        } else if (type === 'book') {
            downs = [ ['Books', links[lp.prefix].children] ]; 
        } else if (type === 'chapter') {
            downs = [ 
                ['Books', links[links[lp.prefix].prefix].children ],
                ['Chapters', links[lp.prefix].children]
            ];
        } else if (type === 'section') {
            downs = [ 
                ['Books', links[links[links[lp.prefix].prefix].prefix].children ],
                ['Chapters', links[links[lp.prefix].prefix].children ],
                ['Sections', links[lp.prefix].children]
            ];
        }
        const drops = downs.map( ([top, items]) => {
            let mret = '<sl-dropdown>\n';
            mret += `<sl-button slot="trigger" caret>${top}</sl-button>\n`;
            mret += items.map( 
                ([name, path]) => `<sl-button class="hide" href="${path}.html">${name}</sl-button>`).
                join('\n');
            mret += '\n</sl-dropdown>\n';
            return mret;
        }).join('\n');
        ret += `<div>${drops}</div>`;
        ret += end;
        return ret;
    }

## Make Path

So this makes the path heading. It should be in the form of
`/book/chapter/section`. The actual page one is on does not have a link which
is the reason for the various branches. 


    (path) => {
        const item = _":item";
        const [ignore, book, chapter, section] = path.split('/').map(e=>e.trim());
        let ret = '<ol>';
        const end = '</ol>';
        if (!book) {
            ret += item('mp', 'MathPebbles', ''); 
            ret += end;
            return ret;
        }
        ret += item('mp', 'MathPebbles', '/index');
        if (!chapter) {
            ret += item('book', book, ''); 
            ret += end; 
            return ret;
        } 
        if (!section) {
            ret += item('book', book, '/'+book); 
            ret += item('chapter', chapter, '');
            ret += end; 
            return ret;
        } 
        ret += item('book', book, '/'+book); 
        ret += item('chapter', chapter, '/'+book + '/' + chapter);
        ret += item('section', section, '');
        ret += end; 
        return ret;
    }

[item]()

This creates a nav item. Not sure the form, so wanted to keep it flexible.
Right now, it is a link. 

    (type, name, path) => {
        if (path) {
            return `<li class="crumb ${type}"><a href="${path.toLowerCase()}.html">${name}</a> </li>`;
        } else {
            return `<li class="crumb ${type}">${name}</li>`;
        }
    }

[css]() 

The crumb setup and css was originally from
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav) 

    .crumbs {
        border-bottom: 1px solid black;
        font-variant: small-caps;
        display:flex;
        justify-content:space-between;
        flex-wrap:wrap;
    }

    .crumbs ol {
        list-style-type: none;
        padding-left: 5px;
    }

    .crumb {
        display: inline-block;
    }

    .crumb a::after {
        display: inline-block;
        color: #000;
        content: '>';
        font-size: 80%;
        font-weight: bold;
        padding: 0 3px;
    }

    .crumbs > div {
        display:inline-flex;
        justify-content: flex-end;
        flex-wrap:wrap;
    }

    .crumbs sl-dropdown {
        margin-right:10px;
    }

    sl-dropdown sl-button {
        width:100%
    }

[junk]()

long ones did not look right

    .crumbs sl-button {
        width:150px;  
    }




## Progress

This returns the css progress class for a given path. 

    (path) => {
        let progress = links[path]?.progress || 0;
        return 'progress-'+progress;
    }
        

## Next Prev

This creates the next and previous buttons. We need the [listings](listings.md
"load:") loaded.



    (path) => {
        const tr = _":transform";
        const home = '\index';
        let prev, next;   
        if (!links.hasOwnProperty(path) ) { 
            console.log('no such path:', path); 
            next = '\arithmetic';
            prev = home;
        } else {
            ({prev, next} = ( links[path.trim()] ) );
        }
        const prevB = `<sl-button class="prev ${progress(prev)}" href="${prev || home}.html">
            <sl-icon name="arrow-left" stye="font-size:20px;"></sl-icon>${tr(prev)}
            </sl-button>`;
        const nextB = `<sl-button class="next ${progress(prev)}" href="${next || home}.html">${tr(next)}<sl-icon name="arrow-right" stye="font-size:20px;"></sl-icon></sl-button>`;
        return `<footer>${prevB} _":middle" ${nextB}</footer>`;
    }

[transform]()

This gives the name for the path. 

    (path) => links[path]?.name || 'MathPebbles' 


[middle]()

This gives the middle pages in the footer: About, FAQ, Settings, Site Map


    <sl-dropdown>
        <sl-button slot="trigger" caret>Non-Mathy Stuff</sl-button>
        <sl-button href="/about.html">About</sl-button>
        <sl-button href="/faq.html">FAQ</sl-button>
        <sl-button href="/support.html">Support</sl-button>
        <sl-button href="/settings.html">Settings</sl-button>
        <sl-button href="/toc.html">Table of Contents</sl-button>
        <sl-button href="/book-index.html">Index of Content</sl-button>
    </sl-dropdown>


[old transform]()

This transforms the path info into human pleasing ideas. 

    (text) => {
        if (!text) {return ''};
        return text.
            slice(1).
            replace(/\//g, ' > ').
            replace(/\-\-/g, ', ').
            replace(/\-/g, ' ');
    }


[css]() 

    footer {
        display: flex;
        flex-wrap:wrap;
        justify-content: space-between;
    }

    footer sl-icon {
        margin-left: 2px;
        margin-right: 2px;
    }
    
    footer {
        font-variant: small-caps;
    }

## Accordion

This is where we put stuff related to making the accordion style detail stuff. 


[css]()
            
    body > sl-details:not(:last-of-type) {
        margin-bottom: var(--sl-spacing-xx-small);
     }

[js]() 

This is where we do some common behavior on event listening. 


    const details = $$('body > sl-details');
    details.forEach( el => { 
        el.addEventListener('sl-show', ev => {
            details.forEach( elEv => (elEv.open = ev.target === details) );
            let path = document.location.pathname.split('/').slice(-1)[0].split('.')[0];
            let hash = document.location.hash.slice(1);
            console.log(hash, path, el.id);
            if (el.id === path) {
                if (hash.length) {
                    document.location.hash = '';
                }
            } else if (hash !== el.id) {
                document.location.hash = el.id;
            }
            let tabby = $('[tabindex]', el);
            if (tabby) {
                tabby.focus();
            } else {
                el.focus();
            }
        });
    });

To have nested details, it was necessary to stop the propagation of the show
events otherwise they would close. Not sure if it is the accordion part. 

    $$('sl-details').forEach( el => {
        el.addEventListener('sl-show', (ev) => ev.stopPropagation());
    });

    let hash = document.location.hash;
    if (hash) {
        $(hash).show();
    } else {
        details[0].show();
    }



## HTML

This is the head of the page, but leaving some stuff for the bottom. We do
reference the css from [common](common.md "load:")

    <!doctype html>
    <html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width,initial-scale=1.0'>
        <meta name='theme-color' content='#333333'>
        <title> !-!TITLE!-! </title>
    
Shoelaces. Load this first so submodules can load while others load. Found if
katex and jsxgraph were first, then they block loading of elements. 

        <link rel="stylesheet" href="/r/shoelace/shoelace.css">
        <script type="module" src="/r/shoelace/shoelace.esm.js"></script>

My homespun Var binding

        <script type="module">
            import {MP} from _"global js:version";
            window.MP = MP;
            window.$ = MP.$
            window.$$ = MP.$$
            
        </script>


        _"global css:version"


Katex  global: katex

        <link rel="stylesheet" href="/r/katex.css">
        <style>.katex { font-size:1em;}</style>
        <script defer src="/r/katex.js" ></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                      {left: '\\\\(', right: '\\\\)', display: false},
                      {left: '\\\\[', right: '\\\\]', display: true}
                    ],
                throwOnError : false
                });
            });
        </script> 



JSXGraph  global: JXG

        
        <script type="text/javascript" charset="UTF-8" defer src="/r/jsxgraphcore.js"></script>
        <link rel="stylesheet" type="text/css" href="/r/jsxgraph.css" />

There is also math.js mainly used for high precision arithmetic. 

        <script typ="text/javascript" charset="UTF-8" defer src="/r/math.js"></script>


        <link rel='manifest' href='manifest.json' crossorigin='use-credentials'>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <link rel="alternate icon" href="/favicon.ico">

        <style>
            .hide  {
                display:none;
            }
            !-!STYLE!-!
        </style>

        !-!HEADER!-!

    </head>
    <body>
    !-!NAV!-!
    !-!BEGIN!-!
    !-!MAIN!-!
    !-!END!-!
    !-!FOOTER!-!
    <script>
         let m;
         document.addEventListener("DOMContentLoaded", function() {
            const {link, Var, show, hide } = MP;
            MP.mathSub(math);
            math.config({number:'BigNumber'});
            let keyInfo = MP.initKeys();
            //let makeScaledNumber = MP.initScaledNumber(math, JXG, keyInfo.keys); 
            let [makeTypedInput, types] = MP.initMakeTypedInput(math, JXG, keyInfo.keys); 
            
            let {scope, inputs, outputs} = MP.makeScope(makeTypedInput);

            !-!SCRIPT!-!
            
            _"set trigger for pebbles"

            _"setup code"
        });

    </script>
    </body>
    </html>


### set trigger for pebbles

Here we listen for show events on details and drawers and then we run the
initiation code in the pebbles object. Just do this once per detail/drawer.
Need to filter out sub details. 

The placement of the pebble initiation code gives it access to any of the
variables in the additional script area. 


    const pebbles = {
        !-!PEBBLES!-!
    };

    const initiatePebble = function initiatePebble (ev) {
        const el = this;
        let allPebbles = $$( '.pebble', el);
        let subPebbles = $$( 'sl-details .pebble, sl-drawer .pebble', el);
        let topPebbles = allPebbles.
            filter( (alEl) => !(subPebbles.some( (subEl) => subEl === alEl ) ) );
        topPebbles.forEach( (topEl) => {
            try{
                pebbles[topEl.id](topEl);
            } catch (e) {
                console.log("Problem with pebble:" + topEl.id, e);
            }
        });
        el.removeEventListener('sl-show', initiatePebble);
    };



    $$('sl-details, sl-drawer').forEach( el => {
        el.addEventListener('sl-show', initiatePebble);
    });


### Setup code


    const code = {
        !-!CODE!-!
    };


We need to setup the code block here. It comes to us with a `pre code` nesting
and we want it to be a textarea. 

We allow for a setup phase of the code. Generally we will want that so that
the coding can be focused on the cool stuff. This might be setting up a
jsxgraph board or some kind of data. 


    $$('.code').
        forEach(par => {
            let codeText = $('code', par)?.innerText || '';
            $('pre', par).outerHTML = \`<div class="container">_":code html"</div><sl-button>Show Working Program</sl-button> \`;
            let con = $('.container', par);
            con.addEventListener('click', (ev) => ev.stopPropagation() );

For the textarea, we want to prevent any other reactions from happening.  

            let ta = $('textarea', par);
            ta.addEventListener('keydown', (ev) => ev.stopPropagation()); 
            let logout = $('.log', par);
            let log = _":log";
            let out = $('.out', par);
            let preRun = code[par.parentNode.dataset.id] || '';  
            $('.run', par).addEventListener('click', () => {
                _":run code"
            });
        })
    ;

[run code]() 


The log function and the out element are available to the eval code. 

    logout.innerText = '';
    try {
       eval(preRun+'\\n'+ta.value);
    } catch(e) {
        log(e);
    }


[log]() 

This is a simple log function. 

    function log (...args) {
        let text = logout.innerText;
        if (text) { args.shift(text) } //adds newline
        text += args.map(
                obj => obj.toString()
            ).join('\\n');
        logout.innerText = text;
    }


[code html]()


    <textarea class="text-code">\${codeText}</textarea>
    <pre class="log"></pre>
    <div class="buttons">
    <sl-button class="save">Save</sl-button>
    <sl-button class="run">Run</sl-button>
    <sl-button class="reset">Reset</sl-button>
    <sl-button class="restore">Restore</sl-button>
    </div>
    <div class="out"></div>

[css]()


    .text-code {
        width:clamp(10px, 70vw, 500px);
        height:150px;
    }


[styling the code]() 

TODO:  https://css-tricks.com/creating-an-editable-textarea-that-supports-syntax-highlighted-code/

This would allow the textareas to have syntax highlighting. 



### Global CSS


    body {
        max-width: 80em;
        margin-left: auto;
        margin-right: auto;
    }



To give space for underline of number, we increase the line height a bit. 

    p {
        line-height: 1.2;
    }

    sl-input {
        width: 20ch;
    }

Specifying width otherwise the explore buttons don't line up. 

    h2.with-explore {
        width:min(90vw, 50em);
        display:flex;
        justify-content: space-between;
        flex-wrap:wrap;
    }

    .explore, .explore:link, .explore:visited {
      background-color: #69ceff;
      font-size:80%;
      color: black;
      padding: 5px 10px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-variant: small-caps;
      border-radius:4px;
    }
    
    .explore:visited {
        filter:brightness(80%);
    }

    .explore:hover, .explore:active, .explore:focus {
      filter: drop-shadow(3px 3px 2px);
      outline:none;
    }

    _"make path:css"
    _"next prev:css"
    _"accordion:css"
    _"shoelace full:css"
    _"setup code:css"
    _"common::css"

        

    
[../public/r/global-1.css](# "save:")

[version]() 

    <link rel='stylesheet' href='/r/global-1.css'>


### Global JS

    
    
    _"common::js"


     document.addEventListener("DOMContentLoaded", function() {

        _"accordion:js"

        _"common::content loaded"
    });


[../public/r/global-1.mjs](# "save:")
    
[version]()

    '/r/global-1.mjs'
            


# Previously useful Abandoned now

## Section Example

This is an example to try out 


[../public/section.html](# "save | page algebra/lines/shortest-distance,_':intro|md', Distance, _':section 1|md', Angles,_':section 2|md'" )

[intro]() 

    This is a sample intro lines

[section 1]()

    The shortest distance between two lines is ...

[section 2]( )

    
    Diffrent cool shapes


## Book Example

This is just the same as the section example except it is a book. 

    _":pieces | page  /algebra/lines, _':intro|md', 
        /algebra/lines/shortest-distance, _':section 1|md', 
        /algebra/lines/circles--angles--and-trianges, _':section 2|md' "


[../public/book.html](# "save" )


[pieces]()

    !- style
    _":style"
    !- script
    _":script"


[style]()

This is an example to try out 


[script]()
        
    console.log('hey');


[intro]() 

    This is a sample intro to lines (preview)

    !-
    
    This should be a longer bit expanded. 


[section 1]()


    The shortest distance between two points is given by the straight line
    between them. 

    !-

    Walk from there to here in the minimu of steps...

    What are the implications of this ...

    Read more in the chapter [Shortest
    Distance](/algebra/lines/shortest-distance). 

[section 2]( )

 
    From the shortest distance, we get a circle. From a circle, we get an
    angle. And with three lines, we get three angles whose figure is called a
    triangle. 

    Read more in the chapter [Circles, Angles, and
    Triangles](/algebra/lines/circles--angles--and-triangles). 

    !-

    What are all the places I can get to that are exactly 1 mile away from
    where I am now? 

    ....


  


